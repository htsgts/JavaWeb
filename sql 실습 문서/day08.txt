Day8

1. Subquery
    - 쿼리의 결과(괄호)가 다른 쿼리에서 사용되는 것
    - 주로 from 절에 괄호를 사용하여 존재
      from 외에도 select, where에도 사용 가능

    * Scalar Subquery
    - subquery 중 select 절에 위치하며
      인풋 1개당 무조건 1개의 결과가 나오는 쿼리
    - 두 개 이상의 결과가 나올 경우
      Oracle에서는 오류처리, 기타 DB에서는 오류 또는 첫 줄만 리턴
      => 보통 여러 줄이 나오는 것을 막기 위해
         limit 1 또는 rownum = 1 의 조건을 주기도 함
    - select에만 영향을 미치면서
      caching 효과(이전에 같은 입력으로 조회한 경우)로 인해
      압도적인 성능을 보임

    select (select 품종명 from 품종코드
            where  race_cd = a.race_cd)
    from   야옹이리스트 a -- 야옹이가 수만마리여도 품종은 수백개 이하

2. exists와 in
    - where 절에 위치하며 특정 조건에 맞는 것이 있는지
      체크하는 쿼리로 유사성을 가지고 있음
    - exists는 존재하는지의 여부만 파악
      in은 특정 집합을 구한 후 그 안에 존재하는지 여부 파악
    - exists 보다 not exists로 더 많이 사용
    예) 오늘 주문한 고객 중 우리 사이트에서 최초로 주문한 고객
        select 고객명, ....
        from   주문 a
        where  a.주문일자 = 오늘
        and    not exists (select 1
                           from   주문 b
                           where  b.고객 = a.고객
                           and    b.주문일자 < a.주문일자)
    - in은 특정 조건의 결과 집합으로 다음 테이블에 이용
    예) 오늘 주문한 고객의 고객명
        select 고객명
        from   고객
        where  고객번호 in (select 고객번호
                           from   주문
                           where  주문일자 = 오늘)

        select hptl_nm, addr
        from   hptl_mast
        where  hptl_nm in ('참사랑병원','경희한의원','부부치과')

3. Join 방식
    - nested loop join(NL join)
      : A 테이블에서 1개 추출하고 이걸 가지고 B 테이블 조회 => 반복
      : 수만건 이하의 조인에서 유용함

    - sort-merge join(SM join)
      : A.타입코드 = B.타입코드
      : 타입코드 순으로 A를 모두 정렬 -> B를 모두 정렬
      : 크기 비교를 하는 경우 특히 유용
      : hash join의 등장으로 등가(=) 조인에서는 힘 없음

    - hash join
      : 대량 대 대량 조인일 경우 엄청난 속도를 보여줌
      : 국민 테이블 대 주소 테이블
        A.주민번호 = B.주민번호
      : A 테이블 전체(where 조건의 A테이블에 대한 조건은 먹임)
        를 가지고 hash bucket을 생성
        => B 테이블 전체를 가지고 hash bucket에 투입

4. Sequence
    - 값을 읽으면(얻으면) 정해진 숫자(대부분 1)만큼 증가하는 오브젝트
    - Primary Key를 얻고자 하는 곳에서 많이 사용된다.

    예) 게시판(Board)
    글번호, 제목, 내용, 작성자, 작성일자, 조회수

    이 중 글번호가 대부분 sequence이다.
    만약 sequence를 사용하지 않는다면
        1) 현재 글번호의 최대값을 얻는다.
        2) 최대값에 1을 더한다.
        3) 그게 내 글번호이다.

    약점) 글이 많을수록 최대값을 찾는데 시간이 오래 걸림
            : 오라클의 인덱스를 거꾸로 읽는 기능이 있어서
              금방 가져올 수 있음 => 다른 DB는 이보다는 느림

         글번호를 뽑고 작성하는 방식으로 웹을 구현한 경우
         => 동시에 글 작성을 하는 경우 먼저 완료 버튼을 누른
            글만 등록된다.
         => 등록 버튼을 누를 때 글 번호를 얻어오는 방식이었어야 함

         sequence를 사용하면 이 모든 문제가 사라짐
         => 단점) 글 번호를 sequence로 먼저 채번하고 작성한다면
                 작성하다가 취소하는 경우 글 번호가 skip된다.

         sequence도 너무 많은 트랜잭션이 동시에 획득하고자 하는 경우
         부하가 걸림(Contention)

5. View
    - 사용자에게 특정한 부분만 보여주기 위한 오브젝트
    - 한 개 테이블에서 만들 수도 있고
      여러 개 테이블에서 만들 수도 있음

    * 주요 사용 목적
    - 사용자가 볼 수 없는(권한이 없는) 데이터를 가린다.
    - 사용자 편의성을 위해 미리 주요 테이블 데이터를 보도록 설계






